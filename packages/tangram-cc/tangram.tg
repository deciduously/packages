import * as std from "tg:std" with {
	path: "../std"
};
import * as rust from "tg:rust" with {
	path: "../rust"
};
import * as zlib from "tg:zlib" with {
	path: "../zlib"
};

export let metadata = {
	name: "cproxy",
	version: "0.0.0"
};

export let source = tg.target(() => tg.directory({
	["Cargo.toml"]: tg.include("./Cargo.toml"),
	["Cargo.lock"]: tg.include("./Cargo.lock"),
	["src"]: tg.include("./src")
}));

// Workaround to get the source directory for the tangram crate. Git dependencies are unsupported by tg:rust.build.
export let tangramSource = tg.target(async () => {
	let owner = "tangramdotdev";
	let name = "tangram";
	let rev = "e0a36420ea2529904795e4b42250036cd26f71dc";
	let download = await std.download({
		url: `https://github.com/${owner}/${name}/archive/${rev.substring(0, 7)}.tar.gz`,
		checksum: "sha256:94f8dc51c4f16dd654e0583723e60f7e8858872daa0fb2e37cd2a73953064424",
		unpackFormat: ".tar.gz",
	});
	tg.assert(tg.Directory.is(download));
	return std.directory.unwrap(download);
});

export let proxyCompiler = tg.target(async () => {
	let sourceDirectory = tg.directory({
		["packages/packages/tangram-cc"]: source(),
		["tangram"]: tangramSource(),
	});

	let built = await rust.build({
		source: tg.symlink(sourceDirectory, "packages/packages/tangram-cc"),
		proxy: false,
	});
	tg.assert(tg.Directory.is(built));
	return tg.directory({
		["bin/cc"]: built.get("bin/tangram-cc"),
		["bin/gcc"]: tg.symlink("cc"),
	});
	return built;
});

// Example: compiling hello world. 
export let testHelloWorld = tg.target(() => {
	let env = std.env(std.sdk(), proxyCompiler());
	let source = tg.directory({
		["main.c"]: tg.file(`
			#include <stdio.h>
			int main() {
				printf("Hello, world!\\n");
				return 0;
			}
		`),
	});
	return std.build(tg`cc ${source}/main.c -o $OUTPUT`, { env });
});

// Example: compiling zlib.
export let testBuildZlib = tg.target(async () => {
	return std.autotools.build(
		{
			phases: { phases: { prepare: "echo 'hi!!' && env" } },
			source: zlib.source(),
			env: [proxyCompiler()],
		},
	);
});

// Example: compiling Perl, but only using the C proxy for main build and not configure tests.
export let testBuildPerl = tg.target(() => {
	let source = perlSource();
	let prepare = tg`cp -r ${source}/. . && chmod -R u+w .`;
	let configure = {
		args: [
			"-des",
			`-Dscriptdir=$OUTPUT/bin`,
			"-Dinstallstyle=lib/perl5",
			"-Dusethreads",
			'-Doptimize="-O3 -pipe -fstack-protector -fwrapv -fno-strict-aliasing"',
		],
		command: "$SHELL Configure",
	};
	let phases = {
		prepare,
		configure,
		build: {
			command: "make",
			args: ["-j8"],
			env: [proxyCompiler()],
		}
	};
	let build = std.autotools.build({
		source,
		phases,
		prefixArg: "-Dprefix=",
	});
	
	return build;
});

export let perlSource = tg.target(async () => {
	let name = "perl";
	let version = "5.38.2";

	// Download raw source.
	let unpackFormat = ".tar.gz" as const;
	let packageArchive = std.download.packageArchive({
		name,
		version,
		unpackFormat,
	});
	let checksum =
		"sha256:a0a31534451eb7b83c7d6594a497543a54d488bc90ca00f5e34762577f40655e";
	let url = `https://www.cpan.org/src/5.0/${packageArchive}`;
	let source = tg.Directory.expect(
		await std.download({ url, checksum, unpackFormat }),
	);
	source = await std.directory.unwrap(source);
	return source;
});

